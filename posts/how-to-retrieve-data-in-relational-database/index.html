<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>关系型数据库如何检索数据 | Zonowry 的博客</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=https://blog.zonowry.com/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=https://blog.zonowry.com/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=https://blog.zonowry.com/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=https://blog.zonowry.com/js/fontawesome.min.8c77c7521b1f95ec2031c2a79f5c6a698aa4a0dba5ba649dfbc7f73994cddf3f494be6aac7e5724f35cbf72cfde09703.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=https://blog.zonowry.com/images/avatar_hu592978886036387a2c13d6a63e534067_442061_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://blog.zonowry.com/images/avatar_hu592978886036387a2c13d6a63e534067_442061_180x180_fill_box_center_3.png><meta name=description content="这条查询已经跑三分钟了，结果出来了吗？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章列表","item":"https://blog.zonowry.com/posts/"},{"@type":"ListItem","position":2,"name":"关系型数据库如何检索数据","item":"https://blog.zonowry.com/posts/how-to-retrieve-data-in-relational-database/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zonowry.com/posts/how-to-retrieve-data-in-relational-database/"},"headline":"关系型数据库如何检索数据 | Zonowry 的博客","datePublished":"2024-04-18T00:00:00+00:00","dateModified":"2024-04-18T00:00:00+00:00","wordCount":3862,"publisher":{"@type":"Person","name":"WANG Chucheng","logo":{"@type":"ImageObject","url":"https://blog.zonowry.com/images/avatar.png"}},"description":"这条查询已经跑三分钟了，结果出来了吗？"}</script><meta property="og:title" content="关系型数据库如何检索数据 | Zonowry 的博客"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.zonowry.com/images/avatar.png"><meta property="og:url" content="https://blog.zonowry.com/posts/how-to-retrieve-data-in-relational-database/"><meta property="og:description" content="这条查询已经跑三分钟了，结果出来了吗？"><meta property="og:locale" content="zh"><meta property="og:site_name" content="Zonowry 的博客"><meta property="article:published_time" content="2024-04-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-18T00:00:00+00:00"><meta property="article:section" content="posts"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Zonowry 的博客</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">首页</a>
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">文章</a>
<a href=/thinks/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">碎碎念</a>
<a href=/firends/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">友链</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>关系型数据库如何检索数据</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2024-04-18</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>8分钟阅读时长</span></div></div><p>说实话研究数据库的底层对常见的项目帮助不大，或者说不受重视，更多是在业务编排上。数据库随便建建，增删改查随便写写，功能就完成了，项目就上线了。但程序员总要有些追求，并且数据库的细节知识很泛用。如 Schema、索引、数据结构、事务、锁，这些知识不止是数据库独有的，说是学习数据库，不如说是借由数据库来学习一下这些知识。<del>不参透数据库设计，就像四大名著不读红楼梦，后面忘了…</del>。</p><blockquote><p>本文主要讨论关系型数据库，可能会顺带一提与 NoSql 相关的知识。</p></blockquote><h2 id=数据库的-schema>数据库的 Schema</h2><p>数据库大多是通过索引、表、数据类型等特性管理数据。但对于<strong>关系型数据库</strong>来说，需要从<strong>强类型</strong>说起。强类型主要是降低调用方的负担，编译期间就会给出报错，将类型错误扼杀在生产之前，不过需要编写强类型的一方“负重前行”。<del>不过大家都会在类型上偷点懒， typescript 经常会被戏称为 anyscript 似乎是个很好的例子。</del></p><p>所谓“负重”，其实就是我们<strong>使用 <code>Schema （模式）</code> 描述一个元素</strong>。Graphql 的接口定义是一个例子，关系型数据库更是如此。使用 Schema 描述表、列、索引、视图、以及外键约束各种关系等。不用钻研 Schema 是如何运作的，只需知道只有数据不会平白无故形成，为此你必须要提供一个 Schema 。</p><p>数据库是通过 <code>Schema</code> 实现对数据结构的高度控制（<strong>强类型</strong>）。进行诸如 <code>create table</code> 操作时，本质就是在写一个 <code>Schema</code> 。</p><blockquote><p><code>NoSQL</code> 一般会被称为 <code>Schemaless</code> 数据库，侧面说明了 <code>NoSQL</code> 弱模式的特性。不过数据通常会有相当“连贯”的结构，为了建立索引，我们还是会<strong>显式</strong>的编写部分 <code>Schema</code> 描述这些 <code>连贯（consistent structure）</code> 的数据。</p></blockquote><h2 id=索引的数据结构>索引的数据结构</h2><p>索引字面上很容易理解，例如 HashMap 和 Array，它们的 <strong>键值 (HashCode)</strong> 和 <strong>元素下标 (Index)</strong> 就是其索引。但数据库作为一个<strong>系统</strong>，在索引上的设计上就略微繁琐一些了，不过索引目的都是<strong>为了提高搜索效率</strong>，避免检索时枚举所有数据。</p><blockquote><p>索引本质是一种数据结构，将数据按照某种规律排列就形成了索引，借用别人的话来说“索引就是排序的艺术”。</p></blockquote><p>考虑在 1 亿条数据中，找到 id 为 4396 的数据这个场景。暴力遍历最差需要枚举 1 亿次才能找到。那 <code>B+Tree</code> 结构如何优化索引，考虑到有序树基本都是参考了二分法的思想，所以先从简单的二分法开始。</p><p>1 亿条数据一直对半分，最坏大概只需要 $log_2(1,0000,0000) \approx 26$ 次查询，可以看出仅仅一个平衡的二叉树（二分法）就可以指数级提升查找效率。</p><p>而数据库通常采用<strong>平衡多叉树</strong>结构，也就是 <code>B+ Tree</code>，<code>B+ Tree</code> 与二叉树最大的区别就是其多叉，即底数 N 可能大于 2，也就降低了阶数。但是每阶可能需要比较 N 次，这样算下来效率好像没有比二叉树好。不过结合现实世界考虑，通过索引磁盘 IO 读取数据的次数约等于树的阶数，多叉树远比二叉树的阶数少，减少了磁盘 IO 次数。</p><p>简单的理解一次 IO 然后 CPU 内存批量判断索引，比精确但频繁的 IO 读取索引挨个判断更快，CPU 是比磁盘快 IO 得多的。这也就是数据库系统中 <code>B+ Tree</code> 也就比二叉树的查询速度更快的原因了。</p><p>但显而易见的一棵多叉树，工作机制类似二分法，搜索效率很高~~（那么代价是什么）~~。但当我们增删数据时，需要分裂、合并叶子节点，那这棵树的结构会受到很大波动。因为树需要按照 <code>B+ Tree</code> 的规则（定义）平衡自己，称之为页的<strong>分裂与合并</strong>，一般是为了保持每个页的大小为 16K。所以常说建立索引后查询变快，但会导致增删改变慢。</p><h2 id=表的存储结构>表的存储结构</h2><p><code>模式 (Schema)</code> 与 <code>索引 (Index)</code> 终归和“物理数据”不太相关，物理数据是如何存储的？主要与<strong>表的存储结构</strong>相关。存储结构直接影响到数据的存储方式，间接影响到增删改查。关系型数据库的存储结构有两种：<code>索引组织表 (Index Organzation Table)</code> 与 <code>堆表 （Heap Table）</code>。</p><blockquote><p><code>NoSql</code> 因为不使用<strong>关系表</strong>，在 <code>NoSql</code> 中或许可以类比的概念是<strong>数据模型</strong>。例如<strong>键值对模型、文档模型、图模型</strong>等。<code>NoSql</code> 按照模型定义把数据存储成<strong>非结构化（unstructured）数据</strong>。</p></blockquote><h3 id=索引组织表>索引组织表</h3><p>表的存储结构依附于索引，物理数据存储在一个索引的 <code>B+ Tree</code> 上，也可以说索引直接指向物理数据，找到了索引，就找到了数据，这个索引称之为<strong>聚集索引</strong>。物理数据只有一份，所以每个表也只能有一个聚集索引，一般为主键（唯一索引）。除聚集索引外的索引就是<strong>二级索引</strong>，也被称为<strong>辅助索引</strong>。</p><p>可以想象聚集索引是有序的，所以物理数据也是有序的，这意味着物理数据存储位置是随索引动态变化的，二级索引只能指向一个聚集索引（主键 ID）。当使用二级索引检索数据时，获取到聚集索引（主键 ID），再用主键 ID 去检索物理数据，这个过程叫作<strong>回表</strong>。</p><h3 id=堆表>堆表</h3><p>堆表则没有<strong>聚集索引</strong>，顾名思义堆表是一个 Heap，物理数据无序的堆在一起。数据与索引分开存储，通过索引只能获取到数据的物理地址（页号、偏移位置），再根据地址去<strong>直取</strong>物理数据。</p><p>表面上看这与索引组织表的<strong>二级索引</strong>机制大致相同，可以说堆表的索引全部都是<strong>二级索引</strong>，但堆表的二级索引不存在<strong>回表</strong>问题。与索引表的二级索引相比，存储的是数据的物理地址，所以少了<strong>回表</strong>步骤，不过与聚集索引相比，还是慢一点的。</p><p>另外显而易见由于堆表无序，所以存储速度比索引表快一些。</p><h2 id=对于索引的优化>对于索引的优化</h2><h3 id=聚集索引>聚集索引</h3><p>聚集索引影响一个表的物理数据存储顺序，数据存储到哪个位置取决于这个聚集索引，会影响存储速度。不过找到索引，也就找到了数据，提升查询速度。数据和索引聚集到一起了，两者间有很强的关系。然后我们把这个索引叫做 <code>聚集索引</code>，这种表结构的存储方式叫做 <code>索引组织表</code>。因为聚集索引影响表的物理数据存储顺序，所以一个表只能有一个聚集索引，通常是根据主键建立的 <code>B+ Tree</code> 索引。</p><p>根据聚集索引特性，我们可以优化的点：</p><ul><li><strong>范围查询时尽量命中聚集索引</strong>，可以降低回表次数。</li><li><strong>更新数据时尽量不更改聚集索引本身</strong>。</li><li><strong>尽量不要离散的增删数据</strong>。例如隔 10 条数据删一条这种。</li></ul><blockquote><p>MySQL 的 InnoDB 存储引擎就采用<strong>索引组织表</strong>。</p></blockquote><h2 id=二级索引-辅助索引非聚集索引>二级索引 (辅助索引/非聚集索引)</h2><p>二级索引的通常只存储了一个指向数据行存储位置的指针~~，当然还有索引列本身（作为键）~~。当我们通过二级索引列查询数据时，会先从辅助索引中找到记录的位置，这个位置上存放了数据行的<strong>指针</strong>。</p><ul><li><strong>在索引组织表结构下拿到的这个数据指针是主键（聚集索引）的值。</strong> 通过主键的值再去<strong>聚集索引树里</strong>查询数据，这个过程叫做<strong>回表</strong><del>，SQL 语句耗时长的多数原因</del>。</li><li><strong>在堆表结构下拿到的数据指针则是数据存放的绝对位置（页码、偏移量）。</strong> 在<strong>堆表</strong>结构下，所有索引都可以看作是二级索引。</li></ul><p>简单想象一个场景，现在我们想根据员工年龄查询数据，但我们目前只有一个用户 ID 列的聚集（主键）索引，数据库需要枚举所有数据再进行筛选。这时候我们就可以为年龄列建立一个二级索引。有了年龄列索引，数据库会先通过年龄列索引查询到符合条件的数据指针，再通过数据指针取到数据。</p><p>堆表与索引表的二级索引在读取数据时小有差异，不过宏观上看都是进行了两次 IO 读写，一次读取索引结构，一次读取数据页。这里可以把索引表的“数据页”看成聚集索引树，所以需要用<strong>主键指针</strong>重新走一遍聚集索引，查找数据。虽然都是两次 IO，不过这个过程肯定是不如堆表的<strong>绝对位置指针</strong>快的，不过也有优化方法。</p><h2 id=覆盖索引>覆盖索引</h2><p><strong>覆盖索引</strong>特性可以改善<strong>索引组织表</strong>的<strong>回表</strong>现象。简单来说，只要我们保证要查询的数据列都是索引列，这样找到二级索引就找到了所需要的数据，避免了再去聚集索引中查询数据。</p><p>例如我们要只想查询用户的 age 和 name，而恰好我们建立了 name 列和 age 列二级组合索引。</p><pre><code class=language-sql>create index on user(age, name)
</code></pre><p>那我们此时应该避免写出类似 <code>select *</code> 语句。</p><pre><code class=language-sql>-- 可能查询到不需要的列，会触发回表
select *
from user where age &gt; 20 order by name
</code></pre><p>原因是查询 user 表没有索引的列会导致<strong>回表</strong>。例如 create_time 没有索引，数据库会再去聚集索引中取 create_time 数据，可我们的业务又不需要 create_time，白白浪费性能。</p><pre><code class=language-sql>select name, age, create_time
from user where age &gt; 20 order by name
</code></pre><p>只需要通过二级索引覆盖了要查询的所有数据，因为 <code>(age,name)</code> 组合索引本身就是 <code>age, name</code> 列的数据，通过这个索引筛选数据时，找到了索引，就找到了数据，所以避免了<strong>回表</strong>操作。</p><pre><code class=language-sql>select name, age from user where age &gt; 20 order by name;
-- or
select age from user where age &gt; 20;
</code></pre><h2 id=数据库锁>数据库锁</h2><p>并发领域中常见术语：锁。</p><blockquote><p>或许可以先看看我的《[[怎样安全的并发编程]]》文章 😳。</p></blockquote><p>数据库根据颗粒度划分出<strong>行级锁</strong>、<strong>页级锁</strong>、<strong>表级锁</strong>。这些锁顾名思义就很容易理解了。根据行为来说的话又有<strong>共享锁</strong>和<strong>互斥锁</strong>。共享锁能够将数据设为只读，任一线程都可以读（共享数据），不过任一线程企图更新数据时都会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。</p><p>结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。A 用户和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，首先为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。</p><pre><code class=language-sql>-- upodate 语句会自动请求互斥锁（锁定需要的数据）
update product set stock = stock - 1 where product_id = x and stock &gt; 0;
</code></pre><p>这句 sql 利用了互斥锁，保证了数据的一致性。但如果放在日经问题“抢购/秒杀”上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知，且数据库链接是昂贵的资源，开了连接却阻塞等待，~~（占着茅坑不拉屎），~~小鸡承受不住呀。</p><p>缓存一招鲜秒了，将 <code>stock</code> 这个数据缓存。当然，缓存那边怎么去实现，就牵扯到更多的缓存数据库设计了，一般是缓存好（预热/懒加载）数据，在缓存中原子性的更改缓存数据（库存）。然后在某个时间点进行一次简单地数据库更新写入，保证缓存与数据库的一致性。</p><pre><code class=language-sql>-- 在某个时刻，写入最新缓存数据。节流数据库写入请求
update product set stock = #{stock_from_cache} where product_id = x
</code></pre><p>也没什么好说的，只要对并发编程理解足够深，把类似概念套用到数据库的锁、事务上也是一样的~~，只要打好基础，写啥都轻松~~。</p><h2 id=参考>参考</h2><ul><li><a href=https://www.mongodb.com/unstructured-data/schemaless>What is a Schemaless Database?</a></li><li><a href=https://www.modb.pro/db/78756>MySQL 为什么不用数组、哈希表、二叉树等数据结构作为索引呢</a></li><li><a href=http://bbs.chinaunix.net/thread-1688208-1-1.html>PostgreSQL 与 MySQL 比较</a></li><li><a href=https://www.modb.pro/db/107906>数据库之堆表和索引组织表 - 墨天轮</a></li></ul></article><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=https://blog.zonowry.com/posts/deploy-k3s-+-rancher-on-pve-container/ class=block>在 PVE 容器上部署 k3s + rancher</a></div></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">zonowry &#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>