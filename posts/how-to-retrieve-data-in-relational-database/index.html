<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="这条查询已经跑三分钟了，结果出来了吗？"><title>关系型数据库如何检索数据</title>
<link rel=canonical href=https://blog.zonowry.com/posts/how-to-retrieve-data-in-relational-database/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="关系型数据库如何检索数据"><meta property='og:description' content="这条查询已经跑三分钟了，结果出来了吗？"><meta property='og:url' content='https://blog.zonowry.com/posts/how-to-retrieve-data-in-relational-database/'><meta property='og:site_name' content='Zonowry'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2024-04-18T00:00:00+00:00'><meta property='article:modified_time' content='2024-04-18T00:00:00+00:00'><meta name=twitter:title content="关系型数据库如何检索数据"><meta name=twitter:description content="这条查询已经跑三分钟了，结果出来了吗？"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_983aea9f35263846.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Zonowry</a></h1><h2 class=site-description>zonowry's blog</h2></div></header><ol class=menu-social><li><a href=https://github.com/zonowry target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:zonowry@outlook.com target=_blank title=Outlook rel=me><svg class="icon icon-tabler icon-tabler-messages" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M21 14l-3-3h-7a1 1 0 01-1-1V4a1 1 0 011-1h9a1 1 0 011 1v10"/><path d="M14 15v2a1 1 0 01-1 1H6l-3 3V11a1 1 0 011-1h2"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#数据库的-schema>数据库的 Schema</a></li><li><a href=#索引的数据结构>索引的数据结构</a></li><li><a href=#表的存储结构>表的存储结构</a><ol><li><a href=#索引组织表>索引组织表</a></li><li><a href=#堆表>堆表</a></li></ol></li><li><a href=#对于索引的优化>对于索引的优化</a><ol><li><a href=#聚集索引>聚集索引</a></li></ol></li><li><a href=#二级索引-辅助索引非聚集索引>二级索引 (辅助索引/非聚集索引)</a></li><li><a href=#覆盖索引>覆盖索引</a></li><li><a href=#数据库锁>数据库锁</a></li><li><a href=#参考>参考</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/how-to-retrieve-data-in-relational-database/>关系型数据库如何检索数据</a></h2><h3 class=article-subtitle>这条查询已经跑三分钟了，结果出来了吗？</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 18, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><p>说实话研究数据库的底层对常见的项目帮助不大，或者说不受重视，更多是在业务编排上。数据库随便建建，增删改查随便写写，功能就完成了，项目就上线了。但程序员总要有些追求，并且数据库的细节知识很泛用。如 Schema、索引、数据结构、事务、锁，这些知识不止是数据库独有的，说是学习数据库，不如说是借由数据库来学习一下这些知识。<del>不参透数据库设计，就像四大名著不读红楼梦，后面忘了…</del>。</p><blockquote><p>本文主要讨论关系型数据库，可能会顺带一提与 NoSql 相关的知识。</p></blockquote><h2 id=数据库的-schema>数据库的 Schema</h2><p>数据库大多是通过索引、表、数据类型等特性管理数据。但对于<strong>关系型数据库</strong>来说，需要从<strong>强类型</strong>说起。强类型主要是降低调用方的负担，编译期间就会给出报错，将类型错误扼杀在生产之前，不过需要编写强类型的一方“负重前行”。<del>不过大家都会在类型上偷点懒， typescript 经常会被戏称为 anyscript 似乎是个很好的例子。</del></p><p>所谓“负重”，其实就是我们<strong>使用 <code>Schema （模式）</code> 描述一个元素</strong>。Graphql 的接口定义是一个例子，关系型数据库更是如此。使用 Schema 描述表、列、索引、视图、以及外键约束各种关系等。不用钻研 Schema 是如何运作的，只需知道只有数据不会平白无故形成，为此你必须要提供一个 Schema 。</p><p>数据库是通过 <code>Schema</code> 实现对数据结构的高度控制（<strong>强类型</strong>）。进行诸如 <code>create table</code> 操作时，本质就是在写一个 <code>Schema</code> 。</p><blockquote><p><code>NoSQL</code> 一般会被称为 <code>Schemaless</code> 数据库，侧面说明了 <code>NoSQL</code> 弱模式的特性。不过数据通常会有相当“连贯”的结构，为了建立索引，我们还是会<strong>显式</strong>的编写部分 <code>Schema</code> 描述这些 <code>连贯（consistent structure）</code> 的数据。</p></blockquote><h2 id=索引的数据结构>索引的数据结构</h2><p>索引字面上很容易理解，例如 HashMap 和 Array，它们的 <strong>键值 (HashCode)</strong> 和 <strong>元素下标 (Index)</strong> 就是其索引。但数据库作为一个<strong>系统</strong>，在索引上的设计上就略微繁琐一些了，不过索引目的都是<strong>为了提高搜索效率</strong>，避免检索时枚举所有数据。</p><blockquote><p>索引本质是一种数据结构，将数据按照某种规律排列就形成了索引，借用别人的话来说“索引就是排序的艺术”。</p></blockquote><p>考虑在 1 亿条数据中，找到 id 为 4396 的数据这个场景。暴力遍历最差需要枚举 1 亿次才能找到。那 <code>B+Tree</code> 结构如何优化索引，考虑到有序树基本都是参考了二分法的思想，所以先从简单的二分法开始。</p><p>1 亿条数据一直对半分，最坏大概只需要 $log_2(1,0000,0000) \approx 26$ 次查询，可以看出仅仅一个平衡的二叉树（二分法）就可以指数级提升查找效率。</p><p>而数据库通常采用<strong>平衡多叉树</strong>结构，也就是 <code>B+ Tree</code>，<code>B+ Tree</code> 与二叉树最大的区别就是其多叉，即底数 N 可能大于 2，也就降低了阶数。但是每阶可能需要比较 N 次，这样算下来效率好像没有比二叉树好。不过结合现实世界考虑，通过索引磁盘 IO 读取数据的次数约等于树的阶数，多叉树远比二叉树的阶数少，减少了磁盘 IO 次数。</p><p>简单的理解一次 IO 然后 CPU 内存批量判断索引，比精确但频繁的 IO 读取索引挨个判断更快，CPU 是比磁盘快 IO 得多的。这也就是数据库系统中 <code>B+ Tree</code> 也就比二叉树的查询速度更快的原因了。</p><p>但显而易见的一棵多叉树，工作机制类似二分法，搜索效率很高~~（那么代价是什么）~~。但当我们增删数据时，需要分裂、合并叶子节点，那这棵树的结构会受到很大波动。因为树需要按照 <code>B+ Tree</code> 的规则（定义）平衡自己，称之为页的<strong>分裂与合并</strong>，一般是为了保持每个页的大小为 16K。所以常说建立索引后查询变快，但会导致增删改变慢。</p><h2 id=表的存储结构>表的存储结构</h2><p><code>模式 (Schema)</code> 与 <code>索引 (Index)</code> 终归和“物理数据”不太相关，物理数据是如何存储的？主要与<strong>表的存储结构</strong>相关。存储结构直接影响到数据的存储方式，间接影响到增删改查。关系型数据库的存储结构有两种：<code>索引组织表 (Index Organzation Table)</code> 与 <code>堆表 （Heap Table）</code>。</p><blockquote><p><code>NoSql</code> 因为不使用<strong>关系表</strong>，在 <code>NoSql</code> 中或许可以类比的概念是<strong>数据模型</strong>。例如<strong>键值对模型、文档模型、图模型</strong>等。<code>NoSql</code> 按照模型定义把数据存储成<strong>非结构化（unstructured）数据</strong>。</p></blockquote><h3 id=索引组织表>索引组织表</h3><p>表的存储结构依附于索引，物理数据存储在一个索引的 <code>B+ Tree</code> 上，也可以说索引直接指向物理数据，找到了索引，就找到了数据，这个索引称之为<strong>聚集索引</strong>。物理数据只有一份，所以每个表也只能有一个聚集索引，一般为主键（唯一索引）。除聚集索引外的索引就是<strong>二级索引</strong>，也被称为<strong>辅助索引</strong>。</p><p>可以想象聚集索引是有序的，所以物理数据也是有序的，这意味着物理数据存储位置是随索引动态变化的，二级索引只能指向一个聚集索引（主键 ID）。当使用二级索引检索数据时，获取到聚集索引（主键 ID），再用主键 ID 去检索物理数据，这个过程叫作<strong>回表</strong>。</p><h3 id=堆表>堆表</h3><p>堆表则没有<strong>聚集索引</strong>，顾名思义堆表是一个 Heap，物理数据无序的堆在一起。数据与索引分开存储，通过索引只能获取到数据的物理地址（页号、偏移位置），再根据地址去<strong>直取</strong>物理数据。</p><p>表面上看这与索引组织表的<strong>二级索引</strong>机制大致相同，可以说堆表的索引全部都是<strong>二级索引</strong>，但堆表的二级索引不存在<strong>回表</strong>问题。与索引表的二级索引相比，存储的是数据的物理地址，所以少了<strong>回表</strong>步骤，不过与聚集索引相比，还是慢一点的。</p><p>另外显而易见由于堆表无序，所以存储速度比索引表快一些。</p><h2 id=对于索引的优化>对于索引的优化</h2><h3 id=聚集索引>聚集索引</h3><p>聚集索引影响一个表的物理数据存储顺序，数据存储到哪个位置取决于这个聚集索引，会影响存储速度。不过找到索引，也就找到了数据，提升查询速度。数据和索引聚集到一起了，两者间有很强的关系。然后我们把这个索引叫做 <code>聚集索引</code>，这种表结构的存储方式叫做 <code>索引组织表</code>。因为聚集索引影响表的物理数据存储顺序，所以一个表只能有一个聚集索引，通常是根据主键建立的 <code>B+ Tree</code> 索引。</p><p>根据聚集索引特性，我们可以优化的点：</p><ul><li><strong>范围查询时尽量命中聚集索引</strong>，可以降低回表次数。</li><li><strong>更新数据时尽量不更改聚集索引本身</strong>。</li><li><strong>尽量不要离散的增删数据</strong>。例如隔 10 条数据删一条这种。</li></ul><blockquote><p>MySQL 的 InnoDB 存储引擎就采用<strong>索引组织表</strong>。</p></blockquote><h2 id=二级索引-辅助索引非聚集索引>二级索引 (辅助索引/非聚集索引)</h2><p>二级索引的通常只存储了一个指向数据行存储位置的指针~~，当然还有索引列本身（作为键）~~。当我们通过二级索引列查询数据时，会先从辅助索引中找到记录的位置，这个位置上存放了数据行的<strong>指针</strong>。</p><ul><li><strong>在索引组织表结构下拿到的这个数据指针是主键（聚集索引）的值。</strong> 通过主键的值再去<strong>聚集索引树里</strong>查询数据，这个过程叫做<strong>回表</strong><del>，SQL 语句耗时长的多数原因</del>。</li><li><strong>在堆表结构下拿到的数据指针则是数据存放的绝对位置（页码、偏移量）。</strong> 在<strong>堆表</strong>结构下，所有索引都可以看作是二级索引。</li></ul><p>简单想象一个场景，现在我们想根据员工年龄查询数据，但我们目前只有一个用户 ID 列的聚集（主键）索引，数据库需要枚举所有数据再进行筛选。这时候我们就可以为年龄列建立一个二级索引。有了年龄列索引，数据库会先通过年龄列索引查询到符合条件的数据指针，再通过数据指针取到数据。</p><p>堆表与索引表的二级索引在读取数据时小有差异，不过宏观上看都是进行了两次 IO 读写，一次读取索引结构，一次读取数据页。这里可以把索引表的“数据页”看成聚集索引树，所以需要用<strong>主键指针</strong>重新走一遍聚集索引，查找数据。虽然都是两次 IO，不过这个过程肯定是不如堆表的<strong>绝对位置指针</strong>快的，不过也有优化方法。</p><h2 id=覆盖索引>覆盖索引</h2><p><strong>覆盖索引</strong>特性可以改善<strong>索引组织表</strong>的<strong>回表</strong>现象。简单来说，只要我们保证要查询的数据列都是索引列，这样找到二级索引就找到了所需要的数据，避免了再去聚集索引中查询数据。</p><p>例如我们要只想查询用户的 age 和 name，而恰好我们建立了 name 列和 age 列二级组合索引。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=k>user</span><span class=p>(</span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>那我们此时应该避免写出类似 <code>select *</code> 语句。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 可能查询到不需要的列，会触发回表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>原因是查询 user 表没有索引的列会导致<strong>回表</strong>。例如 create_time 没有索引，数据库会再去聚集索引中取 create_time 数据，可我们的业务又不需要 create_time，白白浪费性能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=n>create_time</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>只需要通过二级索引覆盖了要查询的所有数据，因为 <code>(age,name)</code> 组合索引本身就是 <code>age, name</code> 列的数据，通过这个索引筛选数据时，找到了索引，就找到了数据，所以避免了<strong>回表</strong>操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- or
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>select</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=数据库锁>数据库锁</h2><p>并发领域中常见术语：锁。</p><blockquote><p>或许可以先看看我的《[[怎样安全的并发编程]]》文章 😳。</p></blockquote><p>数据库根据颗粒度划分出<strong>行级锁</strong>、<strong>页级锁</strong>、<strong>表级锁</strong>。这些锁顾名思义就很容易理解了。根据行为来说的话又有<strong>共享锁</strong>和<strong>互斥锁</strong>。共享锁能够将数据设为只读，任一线程都可以读（共享数据），不过任一线程企图更新数据时都会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。</p><p>结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。A 用户和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，首先为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- upodate 语句会自动请求互斥锁（锁定需要的数据）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>update</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>product_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这句 sql 利用了互斥锁，保证了数据的一致性。但如果放在日经问题“抢购/秒杀”上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知，且数据库链接是昂贵的资源，开了连接却阻塞等待，~~（占着茅坑不拉屎），~~小鸡承受不住呀。</p><p>缓存一招鲜秒了，将 <code>stock</code> 这个数据缓存。当然，缓存那边怎么去实现，就牵扯到更多的缓存数据库设计了，一般是缓存好（预热/懒加载）数据，在缓存中原子性的更改缓存数据（库存）。然后在某个时间点进行一次简单地数据库更新写入，保证缓存与数据库的一致性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 在某个时刻，写入最新缓存数据。节流数据库写入请求
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>update</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>#</span><span class=err>{</span><span class=n>stock_from_cache</span><span class=err>}</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>product_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>也没什么好说的，只要对并发编程理解足够深，把类似概念套用到数据库的锁、事务上也是一样的~~，只要打好基础，写啥都轻松~~。</p><h2 id=参考>参考</h2><ul><li><a class=link href=https://www.mongodb.com/unstructured-data/schemaless target=_blank rel=noopener>What is a Schemaless Database?</a></li><li><a class=link href=https://www.modb.pro/db/78756 target=_blank rel=noopener>MySQL 为什么不用数组、哈希表、二叉树等数据结构作为索引呢</a></li><li><a class=link href=http://bbs.chinaunix.net/thread-1688208-1-1.html target=_blank rel=noopener>PostgreSQL 与 MySQL 比较</a></li><li><a class=link href=https://www.modb.pro/db/107906 target=_blank rel=noopener>数据库之堆表和索引组织表 - 墨天轮</a></li></ul></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 zonowry</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>