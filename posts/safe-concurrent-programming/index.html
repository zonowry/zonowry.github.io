<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="我们仍未确定那天所见变量的状态"><meta name=keywords content="zonowry,怎样安全的并发编程,concurrent,threads,并发,反应式,协程,coroutine,reactive"><title>怎样安全的并发编程</title>
<link rel=canonical href=https://blog.zonowry.com/posts/safe-concurrent-programming/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="怎样安全的并发编程"><meta property='og:description' content="我们仍未确定那天所见变量的状态"><meta property='og:url' content='https://blog.zonowry.com/posts/safe-concurrent-programming/'><meta property='og:site_name' content='Zonowry'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2024-02-29T00:00:00+00:00'><meta property='article:modified_time' content='2024-02-29T00:00:00+00:00'><meta name=twitter:title content="怎样安全的并发编程"><meta name=twitter:description content="我们仍未确定那天所见变量的状态"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_983aea9f35263846.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Zonowry</a></h1><h2 class=site-description>zonowry's blog</h2></div></header><ol class=menu-social><li><a href=https://github.com/zonowry target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:zonowry@outlook.com target=_blank title=Outlook rel=me><svg class="icon icon-tabler icon-tabler-messages" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M21 14l-3-3h-7a1 1 0 01-1-1V4a1 1 0 011-1h9a1 1 0 011 1v10"/><path d="M14 15v2a1 1 0 01-1 1H6l-3 3V11a1 1 0 011-1h2"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#引言>引言</a></li><li><a href=#理论指导实践>理论指导实践</a><ol><li><a href=#抢占式调度>抢占式调度</a></li><li><a href=#协作式调度>协作式调度</a></li></ol></li><li><a href=#实践中的问题>实践中的问题</a><ol><li><a href=#缓存一致性>缓存一致性</a></li><li><a href=#读写有序性>读写有序性</a></li><li><a href=#原子一致性>原子一致性</a></li></ol></li><li><a href=#高速的安全并发>高速的安全并发</a><ol><li><a href=#串行编程>串行编程</a><ol><li><a href=#原子指令>原子指令</a></li><li><a href=#信号量>信号量</a></li></ol></li><li><a href=#不可变变量>不可变变量</a></li><li><a href=#分布式事务>分布式事务</a></li></ol></li><li><a href=#参考>参考</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/safe-concurrent-programming/>怎样安全的并发编程</a></h2><h3 class=article-subtitle>我们仍未确定那天所见变量的状态</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 29, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 11 分钟</time></div></footer></div></header><section class=article-content><h2 id=引言>引言</h2><p>说到并发，首先会想到多线程。若只关注多线程如何使用，却对并发编程没有深入的了解，很容易在代码里挖坑，变成这个段子的模样：“从前有个程序员遇到了一个性能问题。他想，没事，我懂，用线程就好了。现他有在个两题了问“。</p><p>为了避免这种情况，我们该思考“为什么需要多线程，为什么 <code>js</code> 里没有多线程？”等诸类问题。将多线程看成是并发的一种手段，也就是让我们往下面 （the lower）走一点，越过线程理解并发编程。</p><blockquote><p>如果逻辑控制流在时间上重叠，那么它们就是<strong>并发的</strong>（concurrent）
—— 《CSAPP》</p></blockquote><h2 id=理论指导实践>理论指导实践</h2><p>分析 <code>thread（线程）</code>、<code>coroutine（协程）</code>、<code>reactive（反应式）</code>、<code>event/task queue（任务队列）</code> 等各种并发<strong>手段</strong>。不讨论它们的用法、优劣，而是关注它们的的相似之处——它们实际都是通过编排、调度<strong>逻辑控制流</strong>实现的并发。所以只需要搞清楚它们是如何调度<strong>执行单元</strong>的，就掌握了核心<del>科技</del>。</p><blockquote><p>逻辑控制流，底层一点的理解是硬件电路形成的一组逻辑。应用级一点的解释是一个可以被执行的内容，可能是线程、协程、一个可观察对象 Observable、Subscription、FutureTask、Event Callback&mldr;&mldr; 等等。不过用 <code>CSAPP</code> 书中的<strong>逻辑控制流</strong>表示一个可执行内容有点极简，所以下文就称之为<strong>任务</strong>或<strong>执行单元</strong>吧，<strong>代表一个可被执行的片段</strong>（you know it）。</p></blockquote><h3 id=抢占式调度>抢占式调度</h3><p>首先是最常见的抢占式调度，执行单元间呈<strong>竞争</strong>关系，A 任务与 B 任务互相争夺执行机会。最常见的例子是“操作系统内核利用 CPU 时钟中断，达成多线程并发“。每次中断都代表某个线程抢到了 CPU 时间片”。因为 CPU 中断是纳秒级的，实际效果是内核在飞快的切换执行单元以交错执行。提供一种所有执行单元在<strong>并行</strong>的假象。在多核心 CPU 下，内核的抢占式调度也足以实现真正的<strong>并行</strong>。</p><p>抢占式调度下，执行单元无法确定自己什么时候会被执行，且任何时刻都可能会被中断执行。反过来说，只要我们基于此特性，处理好执行单元的竞争与中断，就可以实现一个抢占式调度器。也可以看出抢占式调度的好处是不会存在独占情况——某个执行单元永远占用着 CPU。因为每个执行单元都有被执行的机会，就像在等红绿灯一样。</p><h3 id=协作式调度>协作式调度</h3><p>协作式调度可以引出一大堆技术，例如 <code>IO 多路复用</code> 、<code>迭代器</code>、<code>事件驱动</code> 等等。</p><p>它们都有一个点——主动让渡控制权，或者说主动挂起的（释放并等待）。A 任务与 B 任务可以在<strong>合适</strong>的时机<strong>主动</strong>让渡出控制权。特点是持有控制权的任务主动中断，~~抛开现实不谈（例如 CPU 中断），~~这也突出了协作式调度的优点与理念——“调度不会影响<strong>顺序性</strong>“。因为我们是主动让出的，继续执行时可以找到让渡时的节点来保证顺序性，也可以理解为调度器会帮我们将执行单元恢复到让渡前一刻的状态，然后就像没让渡过一样继续执行。</p><p>协作式调度，执行单元知道自己什么时候会让出，但同时对程序员也是<strong>无感知</strong>的，因为当再次拿到控制权时，协作式调度器可以保持顺序性<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。这个特性提高了程序员们的并发编程体验。于是出现了很多协作式调度框架。抽象的角度看，不论是 <code>Reactive Stream</code>，还是 <code>coroutine</code> ，在我看来都是协作式调度的不同实现。它们都有着执行单元可以主动挂起的特性，与其它执行单元<strong>协作式</strong>的完成逻辑。</p><h2 id=实践中的问题>实践中的问题</h2><p>是时候为线程正名一下了，虽然前面段落回避提及线程，但现在开始线程必不可少，因为线程作为系统内核最小的调度单位，实现<strong>并行</strong>基本<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>离不开线程。协程、反应式等用户态的并发模型到底还是跑在线程上的。</p><p>单线程的话，就不存在着并发编程中的问题，无非就是线程安全了。原因只有<strong>并发环境下访问共享可变的状态</strong>一种。但为什么<strong>共享状态</strong>这个操作会引起问题？因为数据读写不一致。为什么会读写不一致？需要搞清楚并发下计算机是如何读写状态的。</p><blockquote><p>专业一点的说共享状态就是<strong>竞态条件</strong>。也说明两个执行单元可能有某种依赖关系，它们需要协商好谁可以使用这个状态。</p></blockquote><h3 id=缓存一致性>缓存一致性</h3><p>假设计算机的内存<strong>非常快</strong>且<strong>非常大</strong>，那我们就不需要担心<strong>缓存一致性</strong>问题了，为什么？因为每次读取状态，都是最新的状态，这是纳秒级实时读写。<del>（最后说一次，时间要加速了）</del>，这是美好的未来。可现实世界的计算机是有极限的（<del>我不做电子计算机了！JOJO！</del>），计算机的妥协设计是每个 CPU 核心都有一块<strong>独立的</strong>非常快，但非常小的内存，称之为<strong>高速缓存</strong>；再加一块速度尚可（远不及 CPU 计算速度），但非常大的内存，它就是我们的内存条，称之为<strong>主内存</strong>。</p><p>两块内存特性互补，让数据读写不至于拖慢 CPU 计算。妥协的代价就是数据一致性问题，或者说数据可见性问题。因为 cpu 运行一个线程时，需要先从主内存读取数据拷贝到高速缓存里，之后就是 cpu 与高速缓存的时间了，期间 CPU 会适时的将高速缓存里的堆积数据刷写到主内存中。问题出在线程间可以共享数据，会牵扯到<strong>数据同步</strong>（<del>最小的分布式了吧？</del>），有数据同步就不可避免的有一致性问题了，与分布式、数据库领域的<strong>数据一致性</strong>大同小异。</p><p>高级语言为了避免我们太操心这些事情，抽象了运行时内存区域（堆栈、常量区、方法区&mldr;），然后设计了内存模型，负责线程间通信，保证线程间数据同步，线程空间隔离。让多线程容易使用，程序员们要操心的事情变少了（不用和系统底层打交道），但也也让线程间通信变的陷阱重重。</p><h3 id=读写有序性>读写有序性</h3><p>不考虑性能，假设不存在中间<strong>缓存</strong>，每个 CPU 核心实时读写主内存，可以保证所有线程共享数据的<strong>一致性</strong>。但这样能解决线程安全问题吗？还是不行，因为计算机并不会 <code>line by line</code> 的执行代码，因为计算机/虚拟机会在不影响语义的情况下，优化代码的执行顺序。也就是优化后应该与不优化执行的结果一致，称之为<strong>重排序</strong>。</p><p>想象<strong>多个线程</strong>只共享<strong>一个变量</strong>时，我们的假设确实有用——指令重排序对我们来说不会是问题。但<strong>多个线程</strong>共享<strong>多个变量</strong>时，指令重排序的情况就很复杂了。线程是独立的，无法确保另一个线程的重排序会不会影响。举个简单的例子，方便理解：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>var</span> <span class=py>value</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=py>flag</span><span class=p>:</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=err>​</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>value</span> <span class=p>=</span> <span class=m>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>flag</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=err>​</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>getValue</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>flag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>println</span><span class=p>(</span><span class=k>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// thread 1 可能会先执行 flag = true，后执行 value = 8
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>thread</span> <span class=p>{</span> <span class=k>init</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 在这钟情况下，thread 2 则有可能 print 0;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>thread</span> <span class=p>{</span> <span class=n>getValue</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果没有重排序，因为我们知道线程就算是抢占的，交错执行。但也不会造成 <code>print</code>
0 的情况，因为赋值 <code>value = 8</code> 是<strong>原子操作</strong>（下面介绍）。<del>2 个线程，2 个共享变量，非常简单代码，使我的大脑宕机，爱来自&mldr;..</del></p><p>真实的代码会更复杂，可见编译器和 CPU 很难确保<strong>重排序</strong>优化在<strong>多线程多共享</strong>的情况下不会出现异外结果。就像这个理论不该出现的 <code>print</code> 0，即使我们理解线程的交错执行，且阅读并人脑编译了代码可能的执行过程，但因为指令重排序的存在，这一切变得混沌。</p><h3 id=原子一致性>原子一致性</h3><p>进一步假设~~（现在是幻想时间）~~，不存在指令重排序，不存在缓存一致性问题，相当于 <code>java</code> 的 <code>volatile</code> 关键字的效果。线程安全问题还会存在吗？还是会存在，因为程序不仅有指令、数据，还有<strong>算法</strong>（<strong>逻辑</strong>）。</p><p>编排一系列指令形成逻辑，可以称之为<strong>算法</strong>或操作（<del>算法帅一点，所以下文统称算法</del>）。既然是一系列指令，那么每条指令都有可能会被系统内核中断或被其它并行的线程影响，导致算法结果不符合预期。而原子性的百科定义是：</p><blockquote><p>原文：<strong>线性一致性</strong>（Linearizability），或称<strong>原子一致性</strong>或<strong>严格一致性</strong>指的是程序在执行的历史中在存在可线性化点 P 的执行模型，这意味着一个操作将在程序的调用和返回之间的某个点 P 起作用。这里“起作用”的意思是被系统中并发运行的所有其他线程所感知。</p></blockquote><p>大概意思是如果某个指令被执行，其它线程一定会知道这个指令被某个线程执行了，就像单线程一样，等待执行的代码行可以感知到已执行的代码行。或者常见的理解基于「原子是不可再分割的最小物质」并发原子性就是「不可再打断的最小操作序列」。这个解释与<strong>数据库的原子性</strong>「要么全都成功，要么全都失败」异曲同工，当然细说还是有区别的，例如并发的原子性不会 <code>rollback</code> 。</p><p>我的解释是，如果一个算法执行过程中，即使被内核中断切换了线程，或存在共享状态的并行线程，也不会被影响结果。就可以说这个算法是<strong>线程安全</strong>的，也可以理解为算法不会被<strong>打断</strong>，具有原子性。</p><p>原子性我认为是比较容易理解的，因为非原子性算法造成的影响用户态可以很明显的感知到。例如两个线程同时执行 <code>i++</code> ，最后 <code>i</code> 的结果通常会小于预期值。</p><p>无论如何，这是最后一步了，不会继续假设了。只要保证原子性，就可以使线程同步，线程同步了，线程安全问题自然烟消云散。</p><h2 id=高速的安全并发>高速的安全并发</h2><p>步入正题，前文可得，只要我们灵活运用三大特性即可避免线程安全问题。不过我们并发初衷可不是为了安全，而是 fot the speed！速度！</p><p>《Java 并发编程实践》中写过，如何修复线程安全问题：</p><blockquote><p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复该问题：</p><ul><li>不在线程之间共享该状态变量</li><li>将该状态变量修改为不可变的变量</li><li>再访问该状态变量时使用同步</li></ul></blockquote><h3 id=串行编程>串行编程</h3><p>先看最简单的一种：<strong>在访问该状态变量时使用同步</strong>，也就是串行化线程了。</p><p>前文也提到「只要保证了原子性，就可以使线程同步」。可以总结出两种为线程添加原子性的主要方式：</p><ul><li><strong>原子指令</strong>：CPU 指令级别的<strong>原子操作</strong>。如大名鼎鼎的 <code>CAS - 比较并较换</code> 指令。</li><li><strong>信号量</strong>：是一种底层思想，以<strong>信号量的不变性</strong>实现出<strong>原子指令</strong>、<strong>线程锁</strong>。</li></ul><h4 id=原子指令>原子指令</h4><p>原子指令比较容易理解，就像定理一样。从 CPU 硬件级别限制了此指令不会被中断，一但执行，不可取消。</p><p>常见的 <code>CAS</code> 原子指令就是实现各种<strong>乐观锁</strong>的关键，因为 <code>CAS</code> 指令不可被中断，才能保证乐观锁自旋的检测与更新是线程安全的。例如 <code>AtomicInteger</code>。</p><p><strong>原子指令</strong>在性能损耗上大大小于整块代码加锁，但使用场景上也比较受限。~~因为不如加锁一把梭简单。~~对于一段多线程代码，需要人脑编译来判断“仅依靠原子指令是否可以保证线程安全“，说多线程优化通常就是在说这个，依靠原子指令让你的线程锁（阻塞）变少。就像乐观锁做的一样，通过 <code>CAS</code> 指令，来应对多读少写的场景。<del>或者直接改变你的算法逻辑</del></p><h4 id=信号量>信号量</h4><blockquote><p>以提供互斥为目的的二元信号量常常也称为<strong>互斥锁</strong>（mutex）。
——《CSAPP》</p></blockquote><p>同步线程都知道用<strong>线程锁</strong>，常用的线程锁基于<strong>信号量</strong>的思想。使用二元<strong>信号量</strong>变量实现<strong>互斥锁</strong>的例子：</p><ul><li>执行线程前，首先获取信号量<ul><li>如果信号量为 <code>0</code> ，则挂起线程，等待重启，重启后继续判断信号量。</li><li>如果信号量为 <code>1</code> ，则立即返回，并 <code>- 1</code>，这将导致其它线程挂起，本线程执行。</li></ul></li><li>执行线程后（包括被中断），必须释放信号量：<ul><li>将信号量 <code>+ 1</code>，并尝试重启一个因为此信号量挂起的线程。</li></ul></li></ul><p>然后我的建议是不要在信号量、互斥量、自旋锁、乐观锁、悲观锁、互斥锁等等这些术语上浪费太多脑筋。信号量是底层的一种思想，各种锁都是基于这个思想实现的，只是互斥的级别不同，根据锁的用途对锁进行了概念上的分类。不用在名字上过于讲究。</p><h3 id=不可变变量>不可变变量</h3><p><strong>将该状态变量修改为不可变的变量</strong>，很容易理解的一种方式。说起来也很简单：你的共享变量不可变了，相当于只允许读取，必然就不涉及同步问题了。</p><p>做起来的话会很艰难，每个线程的数据都像快照一样。数据一致性的控制权回到了你的手里。需要你来编排数据的“流向”，进入什么数据，出来的会是什么，线程没有了<strong>副作用</strong>，线程的输出你可以预测，就像一条功能明确的加工流水线。</p><blockquote><p>副作用就是指不会对外界产生影响</p></blockquote><p>不可变变量，函数式的思想，一种优雅至极的方案，但会让你束手束脚，不过如果完美贯彻函数式，应该会很流畅，不过需要很高的脑力吧&mldr; 不过尽量让变量不可变，从而让函数保持无副作用，是一种好习惯。</p><h3 id=分布式事务>分布式事务</h3><p>再来看好像最简单的一种：<strong>不在线程之间共享该状态变量</strong>。<del>作者本意应该不是让我们放弃。</del></p><p>其实联想一下，不共享状态，每个线程对于变量的当前正确值是没有感知的，把每个线程看作一个分布式节点，像不像分布式里的数据一致性问题？那瞬间就变的很复杂了。</p><p>不共享状态，但我们又需要访问该状态。只要我们可以接受短暂的线程不安全，退一步，就会有很多方案。可以参考分布式事务的一些成熟做法，例如<strong>最终一致性</strong>、<strong>两阶段提交</strong>等。~~不过这已经算脱离了线程安全话题了，算是数据设计了。~~简单的介绍一下吧，其实纯编程实现没太大意义，通常结合数据库、消息队列等中间件来实现。</p><ul><li><strong>最终一致性</strong>：两个线程执行时，拿到的是共享变量的副本，各自执行完成后，可能还有定时器在不停的纠正数据。</li><li><strong>两阶段提交</strong>：每个线程执行完毕后，发出准备提交的通知。主线程收到所有线程<strong>都准备就绪</strong>后，允许各个线程进行提交。然后各个线程开始提交。</li><li><strong>多版本并发控制</strong>：</li></ul><p>本质上我们就是需要一些保险手段，在尽可能不影响线程效率的情况下，保障数据不出错。</p><h2 id=参考>参考</h2><ul><li><a class=link href=https://jolestar.com/parallel-programming-model-thread-goroutine-actor/ target=_blank rel=noopener>并发之痛 Thread，Goroutine，Actor</a></li><li><a class=link href=https://www.zhihu.com/question/296949412 target=_blank rel=noopener>既然 CPU 有缓存一致性协议（MESI），为什么 JMM 还需要 volatile 关键字？</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>可能会对 <code>rx</code> 的顺序性提出质疑，这里非指过程式一样的代码的编写顺序，例如容易理解的协程的顺序性，而是“可以较为容易”的预测代码执行的顺序。例如 <code>rx</code> 的 <code>obserable.flatmap().reduce().publishOn().map().tap()</code> 例子，还是可以预测出这段代码的整体顺序性的，只是操作符联合起来会很复杂，让人难以理解，不过还是可以说 <code>rx</code> 是有一定顺序性的，毕竟本质上是一个流处理，流的流转过程就是顺序。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>如果不把异步 IO 看作一个特殊的“线程”，那将 IO 读写操作交由内核调度，注册回调后继续干活，变相实现了一个线程逻辑计算的同时，其它 IO 硬件也正在读写数据（如网卡），实现并行处理：一个 IO 硬件，一个 CPU。虽然多数场景我们都是要挂起线程，等待 IO 硬件响应的。再展开就是 IO 模型的话题了，本文不过多讨论，不过也可以看出 IO 模型与并发编程的关系密不可分。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 zonowry</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>