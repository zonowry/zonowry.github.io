<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on Zonowry</title><link>https://blog.zonowry.com/tags/network/</link><description>Recent content in Network on Zonowry</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>zonowry</copyright><lastBuildDate>Fri, 16 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.zonowry.com/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>NAT 穿透在不同环境下的差异</title><link>https://blog.zonowry.com/posts/nat-in-different-environments/</link><pubDate>Fri, 16 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.zonowry.com/posts/nat-in-different-environments/</guid><description>&lt;h2 id="前言">前言
&lt;/h2>&lt;p>有时候会觉得 BT 以及可以实现 P2P 的 VPN 很”魔法“，因为一直对端到端直连的技术细节好像知道，又好像不知道。借着捣鼓了一阵 wireguard 组网，写下本文加深下对 P2P 理解。&lt;/p>
&lt;p>配置这些工具没什么难度，但背后的技术路径却很有意思。 tailscale 那片著名的 NAT 文章讲的很全面，本文也是主要结合这篇文章总结下 NAT 穿透的各种难度。&lt;/p>
&lt;h2 id="完整又原始的-wireguard">完整又原始的 wireguard
&lt;/h2>&lt;p>单纯用 wireguard 实现中转组网的话很简单，只需要一个中转服务器。且有很多的开源工具辅助，例如 wireguard-ui、easy-wireguard&amp;hellip;利用这些工具可以管理各个 peer，生成 conf 文件。&lt;/p>
&lt;p>wireguard 已经足够“完整“了。跨平台的客户端、声明式的配置、自动化的路由 AllowIPs 等等。如上段所说，wireguard 算的上最轻便的组网方案了，一般情况下很好用。&lt;/p>
&lt;p>但想用 vanilla wireugard 实现 &lt;code>peer-to-peer&lt;/code> 直连的话，就要手动配置每个 peer 的 endpoint。如果 peer 的数量是 n ，那么这将是一个 &lt;code>O(n^2 - n)&lt;/code> 的工作，还不包括路由转发的配置工作，并且每个 peer 的公网地址也很难是固定的。&lt;/p>
&lt;p>这些任务很繁重，没有在 github 上找到一个 vanilla wireguard 的自动化处理这些任务的工具，不过基于 wireguard 的上层工具倒是不少。&lt;/p>
&lt;p>最终采用了 headscale，是 tailscale 服务器的开源版，基于 wireguard 实现。也算是一个 wireguard 自动化配置工具。简单配置下即可实现端到端直连需求，tailscale 客户端会自动添加 iptables 规则等路由操作。&lt;/p>
&lt;p>回到正题，接下来从简单到困难，盘点下 NAT 穿透的各种难度。&lt;/p>
&lt;h2 id="最简陋的环境">最简陋的环境
&lt;/h2>&lt;p>首先抽象一个“很简陋”的 NAT 环境下的端到端直连，简陋是指对端防火墙允许一切传入。此时只要一端想办法得到对端的公网地址后，就可以直连。如何得到对端的公网地址也很简单，架设一个类似 DDNS 服务的“协调器”，两个端点访问协调器时，协调器自然可以看到端点的公网地址。&lt;/p>
&lt;p>这个协调器服务称之为 &lt;code>STUN (Session Traversal Utilities for NAT)&lt;/code>，STUN 记录了每个端点的公网 IP，可以告诉各个端点对端的地址，让其自己去建立连接。&lt;/p>
&lt;p>只要各个端点向 STUN 上报自己的地址就可以，虽然很简单，但这样确实就足够了。&lt;/p>
&lt;h2 id="最常见的环境">最常见的环境
&lt;/h2>&lt;p>STUN 的原理看上去十分简单，其实就是很简单。不过当 NAT 环境变得不“简陋”，即对端不允许一切传入，只允许传出的响应数据包。这也是大多 NAT 防火墙的默认配置。此时 STUN 会受到一些限制。&lt;/p>
&lt;p>想象一下这种情况下 STUN 协助端到端建连的过程：首先一端建立一个 socket 访问 STUN 获取对端的地址，接着再建立一个 socket 访问对端，这时当然会被对端的 NAT 防火墙拦截，因为对端拒绝一切传入。&lt;/p>
&lt;p>穿透只能到此为止了吗？前面说到，有状态防火墙允许一种“特殊的传入”，即自身传出的响应，否则我们就没办法愉快问对方是 GG 还是 MM 了。&lt;/p>
&lt;p>回到 STUN 的限制上，就是我们要让对端防火墙认为我们的是“响应”。记得吗，对端也向 STUN 传出了数据包，所以 STUN 知道对端 NAT 此时开放（映射）的地址（端口），这个端口可以接受响应传入。&lt;/p>
&lt;p>另一端则可以向对端的这个端口发送数据包，随后基于这个端口开始通信~~，可以开始为所欲为了~~。显而易见我们用来直连（穿透）的 socket 重用了访问 STUN 的 socket。&lt;/p>
&lt;p>这就是为什么与 STUN 通信和 NAT 穿透要使用同一个 socket。&lt;/p>
&lt;h2 id="有点难度的环境">有点难度的环境
&lt;/h2>&lt;p>STUN 的限制似乎也不是很麻烦，最终来看只是限制只使用一个端口而已。&lt;/p>
&lt;p>不过都知道 NAT 按照所谓的“锥形“分为四个等级，这个“锥形”划分比较抽象，我们不用。更容易理解的分类是 easy nat 和 hard nat，根据“是否依赖目的地址”划分的。&lt;/p>
&lt;p>easy nat 是不依赖目的地址的一种 nat，顾名思义是较为容易穿透 (?) 的 NAT。Esay NAT 的特点是：内网机器同一个 socket 发出去数据包，经过 nat 映射后，nat 为此 socket 创建的端口是固定的。不管这个 socket 是发往 1.1.1.1，还是发往 2.2.2.2 的，即目的地址不相关。这也是我们上一步“最常见的环境”中可以成功直连的原因。&lt;/p>
&lt;p>Hard NAT 就是依赖目的地址那种了，特点是：内网机器就算用同一个 socket 发出的数据包，经过 NAT 后，如果发往目的地址不一致。NAT 会为该 socket 的每一个目的地址映射一个不同的端口，等待目的地址的响应。&lt;/p>
&lt;p>回到 STUN 上，当 Hard NAT 的一端向 STUN 服务器上报地址时，STUN 拿到的是独属于自己（STUN）的地址，只有 STUN 的响应被允许传入，对端的“响应”会被 Hard NAT 拦截。&lt;/p>
&lt;p>想象一个理想的流程，肯定得由 Hard NAT 的一端先向 Easy NAT 的对端发送请求，Esay NAT 的一端拿到了独属于自己的地址（端口），开始基于这个端口开始通信。好像很自然，但问题是此时 Easy NAT 会拦截掉这个数据包，Hard NAT 给我们开放的这个专属端口遗落进网络长河中。&lt;/p>
&lt;p>简单的魔改下 NAT 设备，让其记录下这个对端地址，如果可以办得到的话。除此以外，我们如何找到这个被遗落的端口？&lt;/p>
&lt;p>前文说到 Hard NAT 设备对于 socket 的目的地址是关心的。即同一个 socket 发往 1.1.1.1 与发往 2.2.2.2 的数据包在经过 Hard NAT 设备映射后，是两个端口。所以当两端向对端发送数据包时，各个端点 NAT 设备映射的端口只有自己那端的 NAT 设备自己知道。&lt;/p>
&lt;p>众所周知端口的数量只有 65535 个，让 Easy NAT 背后的端点暴力猜测那个“专属”端口也不是不可以~~（傲娇早就退环境了啊！）~~。不过从 1 开始遍历有点傻，让 Hard NAT 背后的端点多开点 socket 向 Easy NAT 发几次包，再利用点算法（生日悖论）提高猜中的概率。&lt;/p>
&lt;p>当 Easy NAT 一端猜中端口，就可以基于这个端口通信了。&lt;/p>
&lt;h2 id="搞不定的环境">搞不定的环境
&lt;/h2>&lt;p>当一端是 Easy NAT，另一端是 Hard NAT 的话，限制又多了一个穿透必须由 Hard NAT 端发起。但只要从 STUN 服务器拿到对端 IP，再花费几秒钟猜测一次端口，这也是可以接受的。&lt;/p>
&lt;p>可当两端都是 Hard NAT 呢？记得吗，Hard NAT 的映射规则是：&lt;/p>
\[socket,dest ip:port\]&lt;p>，一端打开的每个端口（socket）猜测对端端口时，会映射一个新的端口，对端也是同理，一端的每个端口都要猜 65535 次，单纯暴力的话大概需要两端各进行 65535^2 次，如此巨大的复杂度就算上生日悖论算法也是难以接受。&lt;/p>
&lt;p>所以在两端都是 Hard Nat 情况下的继续采用 STUN 协助打洞目前来看有点不太现实，只能走中转方案。&lt;/p>
&lt;h2 id="9999-可以成功的环境">99.99% 可以成功的环境
&lt;/h2>&lt;p>最常见的一种 NAT 实现就是 Linux 内核 netfilter 框架了，用 iptables 等工具可以简单的配置转换规则，连接的应答包也会自动应用“反向规则”。例如我们只需要配置 SNAT，当应答数据包经过 netfilter hook 时，会自动应用 DNAT （反向 SNAT）。&lt;/p>
&lt;p>这都依托于有状态防火墙的链路追踪，基于这个特性，我们可以得出结论：不管两端的链路经历了多少 NAT 设备节点，最关键的 NAT 节点，始终只有距离发出端和接收端最近的那两个 NAT 节点。就像引用透明的函数式，不管函数多么复杂，其没有副作用。&lt;del>（正如本文的引言，数据包出走半生，归来时一定得是 NAT 设备期望的返回，令人忍俊不禁）&lt;/del>&lt;/p>
&lt;p>综上所述，只要确认有一端是 Easy NAT 就 &lt;code>99.99%&lt;/code> 可以让 N2N 转为 P2P。当出现一端是 Easy NAT 却没有打洞成功的话。肯定是经过了奇奇怪怪的“NAT”，例如各种 proxy vpn。与 STUN 通信经过了 proxy，发出端变成了 proxy 节点，距离发出端最近的 NAT 也就变成了 proxy 节点的 NAT。对于这个 NAT ，我们能做的只有什么都不做。&lt;/p>
&lt;h2 id="百分百可以成功的环境">百分百可以成功的环境
&lt;/h2>&lt;p>端口转发，或者公网 ip，选一个吧。&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener"
>\[译\] NAT - 网络地址转换（2016）&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener"
>\[译\] 深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>红米 AX6S 路由器刷入原版 ImmortalWrt 步骤</title><link>https://blog.zonowry.com/posts/ax6s-openwrt/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.zonowry.com/posts/ax6s-openwrt/</guid><description>&lt;img src="https://blog.zonowry.com/posts/ax6s-openwrt/image-2024_04_01_20_17_39.png" alt="Featured image of post 红米 AX6S 路由器刷入原版 ImmortalWrt 步骤" />&lt;p>直接装整合包的话，大多服务/插件对我都没什么用，&lt;del>感觉卸载也会有残留&lt;/del>所以装个纯净的，可以根据自己需求慢慢完善路由器。&lt;del>最主要的是它很&lt;strong>干净哇&lt;/strong>！&lt;/del>&lt;/p>
&lt;h2 id="启用路由器的-telnet">启用路由器的 telnet
&lt;/h2>&lt;p>为了启用 telnet，需要手动升级路由器固件到开发版，开发版固件可以在 &lt;a class="link" href="https://github.com/YangWang92/AX6S-unlock" target="_blank" rel="noopener"
>GitHub - YangWang92/AX6S-unlock&lt;/a> 仓库下载。(&lt;a class="link" href="https://github.com/YangWang92/AX6S-unlock/blob/master/miwifi_rb03_firmware_stable_1.2.7.bin" target="_blank" rel="noopener"
>miwifi_rb03_firmware_stable_1.2.7.bin&lt;/a>)&lt;/p>
&lt;h2 id="通过-sn-码获取路由器-root-密码">通过 SN 码获取路由器 root 密码
&lt;/h2>&lt;p>在网页 &lt;a class="link" href="https://miwifi.dev/ssh" target="_blank" rel="noopener"
>Xiaomi Router Developer Guide &amp;amp; Tools&lt;/a> 内输入路由器 SN 码，计算出 root 密码。&lt;/p>
&lt;h2 id="telnet-登录路由器开启-ssh-等服务">Telnet 登录路由器开启 ssh 等服务
&lt;/h2>&lt;p>登录 telnet，用户名 root，密码你刚刚拿到了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">telnet 192.168.31.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行以下三条命令，开启些服务，主要是 ssh，照做就是了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">ssh_en&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">uart_en&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">boot_wait&lt;/span>&lt;span class="o">=&lt;/span>on &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">bootdelay&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">flag_try_sys1_failed&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">flag_try_sys2_failed&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">flag_boot_rootfs&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram &lt;span class="nb">set&lt;/span> &lt;span class="s2">&amp;#34;boot_fw1=run boot_rd_img;bootm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nvram &lt;span class="nb">set&lt;/span> &lt;span class="nv">flag_boot_success&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> nvram commit &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> /etc/init.d/dropbear &lt;span class="nb">enable&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> /etc/init.d/dropbear start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="下载纯净原版的-immortalwrt-固件">下载纯净（原版）的 ImmortalWrt 固件
&lt;/h2>&lt;p>&lt;a class="link" href="https://firmware-selector.immortalwrt.org/" target="_blank" rel="noopener"
>ImmortalWrt Firmware Selector&lt;/a>&lt;/p>
&lt;p>搜索自己的路由器型号，下载 &lt;strong>factory.bin&lt;/strong>。&lt;del>如果没有话只能自己编译了&lt;/del>&lt;/p>
&lt;h2 id="通过-scp-上传固件">通过 scp 上传固件
&lt;/h2>&lt;p>scp 上传刚刚下载的原版固件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">scp path/to/file/factory.bin root@192.168.31.1:/tmp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后 ssh 登录路由器，刷写 openwrt 固件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 刷入上一步 scp 传过来的底包&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mtd -r write /tmp/factory.bin firmware
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="访问-openwrt-配置-lan-接口">访问 openwrt 配置 lan 接口
&lt;/h2>&lt;p>原版的 openwrt 网址是 &lt;code>192.168.1.1&lt;/code>。这个 IP 地址可能会和光猫冲突，所以首先编辑 &lt;code>网络/接口/lan&lt;/code>，修改网段为你喜欢的，例如 &lt;code>10.0.0.1&lt;/code>。&lt;/p>
&lt;h2 id="配置路由器拨号">配置路由器拨号
&lt;/h2>&lt;p>配置好 lan 接口后，再配置下 wan 口的 PPPoE 信息，确保路由器可以联网~&lt;/p>
&lt;h2 id="安装-argon-管理界面主题">安装 argon 管理界面主题
&lt;/h2>&lt;p>仓库地址： &lt;a class="link" href="https://github.com/jerrykuku/luci-theme-argon" target="_blank" rel="noopener"
>GitHub - jerrykuku/luci-theme-argon&lt;/a>。&lt;/p>
&lt;p>安装的版本：&lt;a class="link" href="https://github.com/jerrykuku/luci-theme-argon/releases/download/v2.3.1/luci-theme-argon_2.3.1_all.ipk" target="_blank" rel="noopener"
>2.3.1&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">opkg install luci-compat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">opkg install luci-lib-ipkg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># scp path\to\file\luci-theme-argon_2.3.1_all.ipk root@10.0.0.1:/tmp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装 scp 传递下载好的 ipk&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">opkg install /tmp/luci-theme-argon*.ipk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="安装-openclash">安装 openclash
&lt;/h2>&lt;p>仓库地址： &lt;a class="link" href="https://github.com/vernesong/OpenClash" target="_blank" rel="noopener"
>GitHub - OpenClash&lt;/a>。&lt;/p>
&lt;p>安装的版本：&lt;a class="link" href="https://github.com/vernesong/OpenClash/releases/tag/v0.46.003-beta" target="_blank" rel="noopener"
>v0.46.003-beta&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 同理先使用 scp 上传到路由器，然后 opkg 安装&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">opkg install /tmp/luci-app-openclash_0.46.003-beta_all.ipk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装后重启路由器，就可以看到“服务”菜单了。按照自己需求配置 &lt;code>openclash&lt;/code> ，接入&lt;strong>互联网&lt;/strong>。&lt;/p>
&lt;p>![[image-2024_04_01_20_17_39.png]]&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.right.com.cn/forum/thread-8187405-1-1.html" target="_blank" rel="noopener"
>\[2-2\]AX6S 闭源无线驱动 Openwrt 刷机教程/固件下载-小米无线路由器及小米网络设备-恩山无线论坛&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.right.com.cn/forum/thread-8290496-1-1.html" target="_blank" rel="noopener"
>360T7 安装 immortalwrt 官方原版固件（含 Luci Web 页面），供新手参考-360 无线路由器及其他 360 网络设备-恩山无线论坛&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>iptables + clash 透明网关实践与总结</title><link>https://blog.zonowry.com/posts/clash_iptables_tproxy/</link><pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate><guid>https://blog.zonowry.com/posts/clash_iptables_tproxy/</guid><description>&lt;img src="https://arthurchiao.art/assets/img/deep-dive-into-iptables-netfilter/Netfilter-packet-flow.svg" alt="Featured image of post iptables + clash 透明网关实践与总结" />&lt;h1 id="前言">前言
&lt;/h1>&lt;p>尝试用 &lt;code>clash tun&lt;/code> 模式来实现过网关，虽然过程很流畅也比较“新潮“，但对于我来说有点魔法了，因为比较难搞清楚 &lt;code>clash&lt;/code> 帮我们做了哪些工作，出现问题不好找原因。也可能是我比较“洁癖” ，所以我采用了 &lt;code>iptables + tproxy&lt;/code> 这种更加“简单“的方式，&lt;code>clash&lt;/code> 只作为流量中继，流量包的路由都依靠 linux 内核的 &lt;code>netfilter&lt;/code> 模块实现，这样搭建的网关会更加“可控”一点。&lt;/p>
&lt;p>然后我看了不少 &lt;code>clash + linux netfilter(iptables/nftables) 搭建“富强”网关&lt;/code> 的教程文章。步骤都是很简单的，照着做就能实现。但每个人总会有点特殊需求，不去理解这些步骤的奥秘，很难解决一些特殊问题。&lt;/p>
&lt;p>我就是遇到了公网上无法访问我网关上的 &lt;code>docker&lt;/code> 服务，debug 排查了好久，虽然最后凭感觉解决了。但一直没有理顺流量是怎么路由的，只是稍有眉目、模棱两可。所以我去尝试理解了过程中每个操作（命令）的底层逻辑，现在写篇文章梳理一下这些知识。&lt;/p>
&lt;h1 id="linux-网络之-netfilter">linux 网络之 netfilter
&lt;/h1>&lt;p>首先说说这一切的基石：linux 的 &lt;code>netfilter&lt;/code> 模块及延伸工具 &lt;code>iptables&lt;/code>。&lt;/p>
&lt;p>&lt;code>iptables&lt;/code> 只是个命令行工具，依赖 &lt;code>netfilter&lt;/code> 内核模块，也即真正实现防火墙功能的是 linux 内核的 &lt;code>netfilter&lt;/code> 模块。可惜不仅 &lt;code>iptables&lt;/code> 的命令宛若天书，&lt;code>netfilter&lt;/code> 的链路也错综复杂，很难去使用。想要理解使用这些工具或命令，必须得先了解一些 &lt;code>netfilter&lt;/code> 与 &lt;code>iptables&lt;/code> 的基础知识。&lt;/p>
&lt;h2 id="iptables-的链">iptables 的链
&lt;/h2>&lt;p>&lt;code>netfilter&lt;/code> 提供了 &lt;strong>5 个 hook&lt;/strong> 点，&lt;code>iptables&lt;/code> 根据这些 &lt;strong>hook&lt;/strong> 点，搞出了 &lt;code>链 (chain)&lt;/code> 的概念，也就&lt;strong>内置&lt;/strong>了 &lt;strong>5 个默认链&lt;/strong>。可以看出 5 个 &lt;code>iptables chian&lt;/code> 和 5 个 &lt;code>netfilter hook&lt;/code> 一一对应。当然，我们可以添加自定义链，不过想要某个自定义链生效，需要追加一条从&lt;strong>内置链&lt;/strong>跳转到这个自定义链的规则。因为内核的 5 个 hook 点只会触发这 5 个内置链。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>netfilter hook&lt;/th>
&lt;th>iptables chain&lt;/th>
&lt;th>netfilter hook 解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>NF_IP_PRE_ROUTING&lt;/td>
&lt;td>PREROUTING&lt;/td>
&lt;td>接收到的包进入协议栈后立即触发此 hook，在进行任何路由判断 （将包发往哪里）之前&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NF_IP_LOCAL_IN&lt;/td>
&lt;td>INPUT&lt;/td>
&lt;td>接收到的包经过路由判断，如果目的是本机，将触发此 hook&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NF_IP_FORWARD&lt;/td>
&lt;td>FORWARD&lt;/td>
&lt;td>接收到的包经过路由判断，如果目的是其他机器，将触发此 hook&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NF_IP_LOCAL_OUT&lt;/td>
&lt;td>OUTPUT&lt;/td>
&lt;td>  本机产生的准备发送的包，在进入协议栈后立即触发此 hook&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NF_IP_POST_ROUTING&lt;/td>
&lt;td>POSTROUTING&lt;/td>
&lt;td>本机产生的准备发送的包或者转发的包，在经过路由判断之后， 将触发此 hook&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="iptables-的表与动作">iptables 的表与动作
&lt;/h3>&lt;p>&lt;code>iptables&lt;/code> 为了更颗粒度的管理流量，又设计出 &lt;code>table&lt;/code> 的概念。用 &lt;code>table&lt;/code> 来组织这些链，可以理解为每个 &lt;code>table&lt;/code> 根据其用处包含了不同的链。每个 &lt;code>table&lt;/code> 都支持一些“&lt;strong>动作&lt;/strong>“。例如 &lt;code>nat&lt;/code> 表的 &lt;code>DNAT&lt;/code> 动作支持重写目标地址。不过有些动作只在特定的 &lt;code>chain&lt;/code>（或者说 &lt;code>hook&lt;/code>）上才有意义。例如向 &lt;code>INPUT&lt;/code> 链添加 &lt;code>DNAT&lt;/code> 动作时，内核会抛出这个错误：&lt;code>ip_tables: DNAT target: used from hooks INPUT, but only usable from PREROUTING/OUTPUT&lt;/code>。另一个例子是 &lt;code>mangle&lt;/code> 表不允许添加 &lt;code>SNAT&lt;/code> 等动作，所以一个&lt;strong>动作&lt;/strong>需要 &lt;code>table&lt;/code> + &lt;code>chain&lt;/code> 都允许才能被添加。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表&lt;/th>
&lt;th style="text-align: left">支持的内置链&lt;/th>
&lt;th style="text-align: left">支持的动作（部分，仅供参考）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>mangle&lt;/td>
&lt;td style="text-align: left">支持全部 5 个内置链&lt;/td>
&lt;td style="text-align: left">&lt;code>RETURN&lt;/code> &lt;code>TPROXY&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>raw&lt;/td>
&lt;td style="text-align: left">&lt;code>PREROUTING&lt;/code> &lt;code>OUTPUT&lt;/code>&lt;/td>
&lt;td style="text-align: left">&lt;code>TRACE&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nat&lt;/td>
&lt;td style="text-align: left">&lt;code>PREROUTING&lt;/code> &lt;code>INPUT&lt;/code> &lt;code>OUTPUT&lt;/code> &lt;code>POSTROUTING&lt;/code>&lt;/td>
&lt;td style="text-align: left">&lt;code>SNAT&lt;/code> &lt;code>DNAT&lt;/code> &lt;code>REDIRECT&lt;/code> &lt;code>MASQURADE&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td style="text-align: left">&lt;code>INPUT&lt;/code> &lt;code>FORWARD&lt;/code> &lt;code>OUTPUT&lt;/code>&lt;/td>
&lt;td style="text-align: left">略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>security&lt;/td>
&lt;td style="text-align: left">略&lt;/td>
&lt;td style="text-align: left">略&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>每个 &lt;code>table&lt;/code> 的 &lt;code>chain&lt;/code> 当然也是有触发顺序的，具体顺序可以参考那张著名的 &lt;code>netfilter 流程图&lt;/code> ，或&lt;a class="link" href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener"
>这篇文章&lt;/a>的介绍 。&lt;/p>
&lt;div style="background: #fff">
&lt;img src="https://arthurchiao.art/assets/img/deep-dive-into-iptables-netfilter/Netfilter-packet-flow.svg" title="netfilter 流程图"/>
&lt;/div>
&lt;h2 id="流量方向-与-iptables-规则">流量方向 与 iptables 规则
&lt;/h2>&lt;h3 id="开启内核转发功能">开启内核转发功能
&lt;/h3>&lt;p>要想把一台 linux 机器配置成有路由转发功能的机器，第一步需要用以下命令开启内核转发功能。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sysctl -w net.ipv4.ip_forward&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>单单这条命令只是将 linux 机器做成中继路由，一般情况下没太大意义。我们还需要处理途径机器的流量。即设定规则将途径流量“路由（转发）”到本机某些程序上（常用如 &lt;code>clash&lt;/code> 或者 &lt;code>v2ray&lt;/code> ），经代理中转后再原路返回。达成“加速网络”的目的。 &lt;code>iptables&lt;/code> 等相关工具就登场了。&lt;/p>
&lt;h3 id="局域网流量跳过处理直连主路由">局域网流量跳过处理，直连主路由
&lt;/h3>&lt;p>linux 系统是可以作为&lt;strong>主路由&lt;/strong>的，但一般的机器没有多个网口，所以都是作为&lt;strong>旁路由&lt;/strong>来辅助主路由。既然作为旁路由来使用，我们只想代理加速公网流量，局域网内机器的流量肯定还是希望通过&lt;strong>主路由&lt;/strong>来直连，没必要再来来回回途径一次旁路由了。所以需要添加一些&lt;strong>转发规则&lt;/strong>，让旁路由跳过局域网内流量，原封不动转出去，让主路由继续去路由。&lt;/p>
&lt;p>结合 netfilter 段落的知识，逆向思考一下要怎么做。首先我们要添加一些&lt;strong>路由规则&lt;/strong>，这些规则最终肯定是注入到 netfilter hook 里的，可以通过 &lt;strong>iptables chain&lt;/strong> 操作 netfikter hook。所以规则要添加到一个&lt;strong>合适&lt;/strong>的 &lt;strong>chain&lt;/strong> 里，&lt;strong>iptables&lt;/strong> 又是通过 &lt;strong>table&lt;/strong> 来组织管理 &lt;strong>chain&lt;/strong> 的。我们还需要找一个&lt;strong>合适&lt;/strong>的 &lt;strong>table&lt;/strong> 来添加 &lt;strong>chain&lt;/strong>（或者说规则）。思考了这些后，我们再回头看命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># clash 链负责处理转发流量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -N clash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 让所有流量通过 clash 链进行处理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A PREROUTING -j clash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 目标地址为局域网或保留地址的流量跳过处理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>首先我们新建了一个自定义链管理规则：&lt;code>iptables -t mangle -N clash&lt;/code>&lt;/li>
&lt;li>然后从内置链 &lt;code>PREROUTING&lt;/code> 跳转而来：&lt;code>iptables -t mangle -A PREROUTING -j clash&lt;/code>
&lt;ul>
&lt;li>当然我们可以直接不写这两句，直接将规则添加到 &lt;code>PREROUTING&lt;/code> 链。但那样写不是很规范，不推荐直接向内置链（这里是 &lt;code>PREROUTING&lt;/code> ）添加规则。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>然后追加局域网 IP 直连规则到 &lt;code>clash&lt;/code> 表中
我们使用的表是 mangle 表，链是 链。
总而言之，最终实现了局域网机器流量发到&lt;strong>旁路由&lt;/strong>时，旁路由发现目标地址是局域网内 ip，跳过处理，转发出去给到主路由，就是主路由和源主机直接通信了，之后的网络传输本网关就不会参与了。&lt;/li>
&lt;/ul>
&lt;h3 id="中转外网流量clash-透明代理">中转外网流量，clash 透明代理
&lt;/h3>&lt;p>由于上一步我们跳过了内部（局域网内）流量，剩下的流量基本就是外部（互联网）流量了。这些&lt;strong>外部流量&lt;/strong>应该要转发到 &lt;code>clash&lt;/code> 中进行透明代理。&lt;/p>
&lt;p>虽然可以简单的通过 &lt;code>REDIRECT&lt;/code> 动作将流量转发到 &lt;code>7893&lt;/code> 端口。但 &lt;code>REDIRECT&lt;/code> 不能很好的支持 &lt;code>UDP&lt;/code> 流量。所以采用 &lt;code>TPROXY&lt;/code> 方式，这样 &lt;code>TCP&lt;/code> 和 &lt;code>UDP&lt;/code> 都能支持。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># tproxy 7893（clash） 端口，并打上 mark 666 命中策略，走 666 路由表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -p tcp -j TPROXY --on-port &lt;span class="m">7893&lt;/span> --tproxy-mark &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash -p udp -j TPROXY --on-port &lt;span class="m">7893&lt;/span> --tproxy-mark &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 转发所有 DNS 查询到 1053 端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 此操作会导致所有 DNS 请求全部返回虚假 IP(fake ip 198.18.0.1/16)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t nat -I PREROUTING -p udp --dport &lt;span class="m">53&lt;/span> -j REDIRECT --to &lt;span class="m">1053&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加策略与路由表（）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ip rule add fwmark &lt;span class="m">666&lt;/span> lookup &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ip route add &lt;span class="nb">local&lt;/span> 0.0.0.0/0 dev lo table &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前两句 &lt;code>iptables&lt;/code> 命令，追加了两条 &lt;code>TPROXY&lt;/code> 规则。将 &lt;code>tcp&lt;/code> &amp;amp; &lt;code>udp&lt;/code> 流量转发到 &lt;code>clash&lt;/code> 的 &lt;code>7893&lt;/code> 端口，且打了 &lt;code>666&lt;/code> 标记。&lt;/p>
&lt;p>因为 &lt;code>TPROXY&lt;/code> 不会修改 IP 数据包，数据包的 dest ip 一般都是外网地址，所以数据包下一跳会直接 forward 转出到下一跳机器上。因此 &lt;code>TPROXY&lt;/code> 大部分情况都需要搭配 &lt;code>ip route&lt;/code> 策略路由一起使用。比如我们这里就是新建了一个名为 &lt;code>666&lt;/code> 的路由表，此路由表会将所有数据包发到本地回环上。这样就阻断了 forward 过程，相当于让（ &lt;code>tproxy&lt;/code> 过的）数据包重新走一边网络栈流程。这样数据包就可以转发到 &lt;code>7893&lt;/code> 端口上了，然后我们只让有 &lt;code>666&lt;/code> 标记的数据包经过此路由表。&lt;/p>
&lt;h3 id="代理网关本机的流量">代理网关本机的流量
&lt;/h3>&lt;p>经过以上步骤，局域网内的其它机器已可以正常使用本网关了。当然，一台 llinux 机器只用来当一个网关太浪费了，还可以跑各种服务以及日常使用。顺便将本机的流量也代理一下，也即代理本机发出（经过 &lt;code>OUTPUT&lt;/code> 链）的数据包。&lt;/p>
&lt;p>首先与上一步类似的步骤，将本机发出的流量（OUTPUT）打上标记，触发重新路由。这样本机发出的流量就和局域网内其它机器进入的流量相同了，路由的流程也就一样了。不过 &lt;code>OUTPUT&lt;/code> 上的数据包也会包含 clash 发出流量，这样会出现数据包死循环，得处理一下。只需要跳过 clash 程序发出的数据包，避免死循环。用 clash 用户启动 clash 程序，根据 uid 跳过数据包即可。。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># clash_local 链负责处理网关本身发出的流量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -N clash_local
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># nerdctl 容器流量重新路由&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#iptables -t mangle -A clash_local -i nerdctl2 -p udp -j MARK --set-mark 666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#iptables -t mangle -A clash_local -i nerdctl2 -p tcp -j MARK --set-mark 666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 跳过内网流量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 0.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 127.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 10.0.0.0/8 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 172.16.0.0/12 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 192.168.0.0/16 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 169.254.0.0/16 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 224.0.0.0/4 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -d 240.0.0.0/4 -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 为本机发出的流量打 mark&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -p tcp -j MARK --set-mark &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A clash_local -p udp -j MARdocK --set-mark &lt;span class="m">666&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 跳过 clash 程序本身发出的流量, 防止死循环(clash 程序需要使用 &amp;#34;clash&amp;#34; 用户启动)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A OUTPUT -p tcp -m owner --uid-owner clash -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner clash -j RETURN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 让本机发出的流量跳转到 clash_local&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># clash_local 链会为本机流量打 mark, 打过 mark 的流量会重新回到 PREROUTING 上&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">iptables -t mangle -A OUTPUT -j clash_local
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="外网访问内网-docker-问题">外网访问内网 docker 问题
&lt;/h2>&lt;p>也可以说外网访问局域网内机器（非网关机器）的问题。我们这样配置好后，会发现无法从外网访问内网的 docker 服务（设置路由器端口转发）。可以通过手机流量访问测试。&lt;/p>
&lt;p>我是参考该 &lt;a class="link" href="https://github.com/Dreamacro/clash/issues/432#issuecomment-571634905" target="_blank" rel="noopener"
>github issue&lt;/a> 受到了启发，最终解决了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 跳过 docker0 的 ip 范围。即跳过 docker 服务的出站数据包&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo iptables -t mangle -A clash -p tcp -s 172.18.0.0/16 -j RETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后以下是个人的推测，可能有误，仅供参考。&lt;/p>
&lt;p>首先手机入站数据包经过路由器，&lt;code>NAT&lt;/code> 到 &lt;code>docker&lt;/code> 服务（网关机器）上。此时因为 &lt;strong>dest ip&lt;/strong> 是内网 ip，&lt;strong>clash 链&lt;/strong> 会跳过。&lt;strong>DOCKER 链&lt;/strong> 接手处理，通过 &lt;code>DNAT&lt;/code> 转发到了 &lt;strong>docker0 bridge&lt;/strong> 网卡上，这几步都很正常。顺利到达 docker 容器。&lt;/p>
&lt;p>随后是 docker 容器的出站数据包，此时数据包会从 &lt;strong>docker0 bridge&lt;/strong> 发到宿主机的物理网卡 &lt;strong>eth&lt;/strong> 网卡。这时数据包之于宿主机来说，是一个入站数据包。数据包会经过 &lt;code>PREROUTING&lt;/code> 链，jump 到 &lt;strong>clash&lt;/strong> 链，而此时的 &lt;strong>dest ip&lt;/strong> 为手机的 ip 。会被转发到 clash 上处理，但这个数据包只在出站时转发给 clash 处理。入站的时候跳过了。估计 clash 无法处理这个数据包，可能就丢弃了。就出现了外网无法访问内网 docker 容器的问题。&lt;/p>
&lt;p>所以根据 source ip 判断， 将 docker 容器的数据包也跳过。跳过后就解决了～&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://moecm.com/something-about-v2ray-with-tproxy/" target="_blank" rel="noopener"
>第一篇万字长文：围绕透明代理的又一次探究&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener"
>「译」深入理解 iptables 和 netfilter 架构&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://mritd.com/2022/02/06/clash-tproxy/" target="_blank" rel="noopener"
>树莓派 Clash 透明代理(TProxy)_&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/mritd/tpclash/wiki/2%E3%80%81%E8%BF%9B%E9%98%B6%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener"
>tpclash wiki - 2、进阶流量控制&lt;/a> 。&lt;/li>
&lt;li>&lt;a class="link" href="https://tinychen.com/20200414-iptables-principle-introduction/" target="_blank" rel="noopener"
>iptables 的四表五链与 NAT 工作原理  _&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.zhaohuabing.com/learning-linux/docs/tproxy/" target="_blank" rel="noopener"
>https://www.zhaohuabing.com/learning-linux/docs/tproxy/&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>